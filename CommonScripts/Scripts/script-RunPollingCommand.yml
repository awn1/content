commonfields:
  id: RunPollingCommand
  version: -1
name: RunPollingCommand
fromversion: 5.0.0
script: >
  register_module_line('RunPollingCommand', 'start', __line__())

  demisto.debug('pack name = Common Scripts, pack version = 1.19.29')





  def prepare_arg_dict(ids_arg_name, ids, additional_arg_names, additional_arg_values, using_instance=''):
      if not isinstance(ids, list):
          ids = [ids]
      for i, val in enumerate(ids):
          ids[i] = str(ids[i])

      args_names = [str(name).strip() for name in argToList(additional_arg_names)]
      args_values = [str(value).strip() for value in argToList(additional_arg_values)]

      if len(args_names) != len(args_values):
          raise ValueError('arg names and arg values lists does not match, please check your inputs:\n'
                           'arg names ({}): {}\narg values ({}): {}'.format(len(args_names), args_names,
                                                                            len(args_values), args_values)
                           )

      args = dict(zip(args_names, args_values))
      args[ids_arg_name] = ','.join(argToList(ids))
      if using_instance:
          args['using'] = str(using_instance)

      return args


  def main(args):     # pragma: no cover
      try:
          encoded_id = args.get('ids')

          additional_polling_command_arg_names = args.get('additionalPollingCommandArgNames')

          additional_polling_command_arg_values = args.get('additionalPollingCommandArgValues')

          using = args.get('using', '')
          using_instance = using

          args = prepare_arg_dict(args.get('pollingCommandArgName'),
                                  encoded_id,
                                  additional_polling_command_arg_names,
                                  additional_polling_command_arg_values,
                                  using_instance
                                  )

          demisto.results(demisto.executeCommand(demisto.getArg('pollingCommand'), args))
      except Exception as exp:
          return_error('An error occurred: {}'.format(exp), error=exp)


  if __name__ in ['__main__', 'builtin', 'builtins']:
      main(demisto.args())

  register_module_line('RunPollingCommand', 'end', __line__())
type: python
subtype: python3
tags: []
comment: "Runs a specified polling command one time. This is useful for initiating a local playbook context before running a polling scheduled task.\n\nThis automation runs using the default Limited User role, unless you explicitly change the permissions.\nFor more information, see the section about permissions here:\n- For Cortex XSOAR 6 see https://docs-cortex.paloaltonetworks.com/r/Cortex-XSOAR/6.x/Cortex-XSOAR-Playbook-Design-Guide/Automations \n- For Cortex XSOAR 8 Cloud see https://docs-cortex.paloaltonetworks.com/r/Cortex-XSOAR/8/Cortex-XSOAR-Cloud-Documentation/Create-a-script\n- For Cortex XSOAR 8.7 On-prem see https://docs-cortex.paloaltonetworks.com/r/Cortex-XSOAR/8.7/Cortex-XSOAR-On-prem-Documentation/Create-a-script"
enabled: true
args:
- name: ids
  required: true
  description: List of IDs to poll.
- name: pollingCommand
  required: true
  description: Name of the polling command to run.
- name: pollingCommandArgName
  required: true
  description: Name of the argument of the polling command.
  defaultValue: ids
- name: additionalPollingCommandArgNames
  description: Commas separated arguments of the polling command.
- name: additionalPollingCommandArgValues
  description: Commas separated arguments values of the polling command.
scripttarget: 0
tests:
- No test
dockerimage: demisto/python3:3.11.10.116949
nativeimage:
- '8.8'
- '8.6'
