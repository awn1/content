.build-machines-cleanup-rule:
  rules:
    - if: '$BUILD_MACHINES_CLEANUP == "true"'

.build-machines-cleanup-rule-always:
  rules:
    - if: '$BUILD_MACHINES_CLEANUP == "true"'
      when: always

.create_artifacts_and_server_type_instance_folders: &create_artifacts_and_server_type_instance_folders
  - section_start "Create Artifacts, Server Instance, Server Type folders" --collapsed
  - |
    if [[ -n "${ARTIFACTS_FOLDER}" ]] && [[ ! -d "${ARTIFACTS_FOLDER}/logs" ]]; then
      echo "Creating Artifacts folder: ${ARTIFACTS_FOLDER} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER}/logs" # using the -p to create the logs folder as well.
    fi
  - |
    if [[ -n "${ARTIFACTS_FOLDER_INSTANCE}" ]] && [[ ! -d "${ARTIFACTS_FOLDER_INSTANCE}/logs" ]]; then
      echo "Creating Artifacts instance folder: ${ARTIFACTS_FOLDER_INSTANCE} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER_INSTANCE}/logs" # using the -p to create the logs folder as well.
      echo "${INSTANCE_ROLE}" > "${ARTIFACTS_FOLDER_INSTANCE}/instance_role.txt"
    fi
  - |
    if [[ -n "${ARTIFACTS_FOLDER_SERVER_TYPE}" ]] && [[ ! -d "${ARTIFACTS_FOLDER_SERVER_TYPE}/logs" ]]; then
      echo "Creating Artifacts Server type folder: ${ARTIFACTS_FOLDER_SERVER_TYPE} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER_SERVER_TYPE}/logs" # using the -p to create the logs folder as well.
      echo "${SERVER_TYPE}" > "${ARTIFACTS_FOLDER_SERVER_TYPE}/server_type.txt"
    fi
  - section_end "Create Artifacts, Server Instance, Server Type folders"


.download-content-test-conf: &download-content-test-conf
  - section_start "Download content test conf" --collapsed
  - exec 3>&1 4>&2
  - exec > >(tee -a "${ARTIFACTS_FOLDER}/logs/download_demisto_conf.log") 2>&1
  - |
    set +e

    RED='\033[0;31m'
    GREEN='\033[0;32m'
    NC='\033[0m'

    clone_repository() {
      local host=$1
      local user=$2
      local token=$3
      local repo_name=$4
      local branch=$5
      local retry_count=$6
      local sleep_time=${7:-10}  # default sleep time is 10 seconds.
      local exit_code=0
      local i=1
      echo -e "${GREEN}Cloning ${repo_name} from ${host} branch:${branch} with ${retry_count} retries${NC}"
      if [ -z "${user}" ] && [ -z "${token}" ]; then
        user_info=""
      else
        user_info="${user}:${token}@"
        # If either user or token is not empty, then we need to add them to the url.
      fi
      for ((i=1; i <= retry_count; i++)); do
        git clone --depth=1 "https://${user_info}${host}/${repo_name}.git" --branch "${branch}" && exit_code=0 && break || exit_code=$?
        if [ ${i} -ne "${retry_count}" ]; then
          echo -e "${RED}Failed to clone ${repo_name} with branch:${branch}, exit code:${exit_code}, sleeping for ${sleep_time} seconds and trying again${NC}"
          sleep "${sleep_time}"
        else
          echo -e "${RED}Failed to clone ${repo_name} with branch:${branch}, exit code:${exit_code}, exhausted all ${retry_count} retries${NC}"
          break
        fi
      done
      return ${exit_code}
    }

    clone_repository_with_fallback_branch() {
      local host=$1
      local user=$2
      local token=$3
      local repo_name=$4
      local branch=$5
      local retry_count=$6
      local sleep_time=${7:-10}  # default sleep time is 10 seconds.
      local fallback_branch="${8:-master}"

      # Check if branch exists in the repository.
      echo -e "${GREEN}Checking if branch ${branch} exists in ${repo_name}${NC}"
      if [ -z "${user}" ] && [ -z "${token}" ]; then
        user_info=""
      else
        # If either user or token is not empty, then we need to add them to the url.
        user_info="${user}:${token}@"
      fi
      git ls-remote --exit-code --quiet --heads "https://${user_info}${host}/${repo_name}.git" "refs/heads/${branch}" 1>/dev/null 2>&1
      local branch_exists=$?

      if [ "${branch_exists}" -ne 0 ]; then
        echo -e "${RED}Branch ${branch} does not exist in ${repo_name}, defaulting to ${fallback_branch}${NC}"
        local exit_code=1
      else
        echo -e "${GREEN}Branch ${branch} exists in ${repo_name}, trying to clone${NC}"
        clone_repository "${host}" "${user}" "${token}" "${repo_name}" "${branch}" "${retry_count}" "${sleep_time}"
        local exit_code=$?
        if [ "${exit_code}" -ne 0 ]; then
          echo -e "${RED}Failed to clone ${repo_name} with branch:${branch}, exit code:${exit_code}${NC}"
        fi
      fi
      if [ "${exit_code}" -ne 0 ]; then
        # Trying to clone from fallback branch.
        echo -e "${RED}Trying to clone repository:${repo_name} with fallback branch ${fallback_branch}!${NC}"
        clone_repository "${host}" "${user}" "${token}" "${repo_name}" "${fallback_branch}" "${retry_count}" "${sleep_time}"
        local exit_code=$?
        if [ ${exit_code} -ne 0 ]; then
          echo -e "${RED}ERROR: Failed to clone ${repo_name} with fallback branch:${fallback_branch}, exit code:${exit_code}, exiting!${NC}"
          exit ${exit_code}
        else
          echo -e "${GREEN}Successfully cloned ${repo_name} with fallback branch:${fallback_branch}${NC}"
          return 0
        fi
      else
        echo -e "${GREEN}Successfully cloned ${repo_name} with branch:${branch}${NC}"
        return 0
      fi
    }

    clone_repository_with_fallback_branch "${CI_SERVER_HOST}" "gitlab-ci-token" "${CI_JOB_TOKEN}" "${CI_PROJECT_NAMESPACE}/content-test-conf" "${CI_COMMIT_REF_NAME}" 3 10 "master"

    mkdir -p ./Config
    cp -r ./content-test-conf/Config/* ./Config

    NAME_MAPPING_PATH="./Config/name_mapping.json"
    if [ ! -f "$NAME_MAPPING_PATH" ]; then
      echo "File $NAME_MAPPING_PATH does not exist";
      # echo "File $NAME_MAPPING_PATH does not exist, check if the file exists in the content-test-conf repo under the Config folder";
      # exit 1;
    fi

    set -e
    echo "Successfully cloned content-test-conf repository"

  - exec 1>&3 2>&4
  - exec 3>&- 4>&-
  - section_end "Download content test conf"

.before-script-build-machines-cleanup:
  before_script:
    - source .gitlab/helper_functions.sh
    - !reference [.setup-network-certs]
    - !reference [.poetry-install]
    - !reference [.granting_execute_permissions_on_files]
    - !reference [.setup-artifactory]
    - *create_artifacts_and_server_type_instance_folders
    - *download-content-test-conf

.lock-machine:
  - section_start "Lock Machine" --collapsed
  - echo "Authenticating GCP"
  - gcloud auth activate-service-account --key-file="$GCS_ARTIFACTS_KEY" >> "${ARTIFACTS_FOLDER}/logs/gcloud_auth.log" 2>&1
  - echo "Auth done successfully"
  - ./Tests/scripts/wait_in_line_for_cloud_env.sh "$CLOUD_MACHINES_TYPE"
  - source CloudEnvVariables
  - echo "CLOUD Chosen machine ids are:${CLOUD_CHOSEN_MACHINE_IDS}" | tee "${ARTIFACTS_FOLDER}/logs/lock_file.txt"
  - section_end "Lock Machine"

.uninstall-packs-and-reset-bucket-cloud:
  - section_start "Uninstall Packs and Reset Bucket Cloud" --collapsed
  - ./Tests/scripts/uninstall_packs_and_reset_bucket_cloud.sh || EXIT_CODE=$?
  - section_end "Uninstall Packs and Reset Bucket Cloud"

.cloud-machine-information:
  - section_start "Cloud Machine information"
  - ./Tests/scripts/print_cloud_machine_details.sh
  - section_end "Cloud Machine information"

.unlock-machine:
  - section_start "Unlock Machine" --collapsed
  - |
    if [[ -f "CloudEnvVariables" ]]; then
      source CloudEnvVariables

      if [[ -n "${CLOUD_CHOSEN_MACHINE_IDS}" ]]; then
        if [[ -e "${ARTIFACTS_FOLDER}/logs/lock_file.txt" ]]; then
          echo "Job finished, removing lock file for machine ids:${CLOUD_CHOSEN_MACHINE_IDS}"
          gcloud auth activate-service-account --key-file="$GCS_ARTIFACTS_KEY" >> "${ARTIFACTS_FOLDER}/logs/gcloud_auth.log" 2>&1
          gsutil rm "gs://xsoar-ci-artifacts/$GCS_LOCKS_PATH/machines_locks/*-lock-$CI_PIPELINE_ID*"
          echo "Finished removing lock file(s)"
        else
          echo "No lock file found, skipping unlocking"
        fi
      else
        echo "No machine ids were chosen, skipping unlocking"
      fi
    else
      echo "No CloudEnvVariables file found, skipping unlocking"
    fi
  - section_end "Unlock Machine"

stages:
  - security

build-machines-cleanup:
  stage: cleanup
  extends:
    - .build-machines-cleanup-rule
    - .before-script-build-machines-cleanup
  script:
    - EXIT_CODE=0
    - |
      XSIAM_SERVERS_PATH="./xsiam_servers.json"
      echo ${XSIAM_SERVERS_PATH} > xsiam_servers_path
      echo "lock machine name ${LOCK_MACHINE_NAME}"
    - if [[ -n "$LOCK_MACHINE_NAME" ]]; then
    -   echo "Check if lock file already exist "
    -   gcloud auth activate-service-account --key-file="$GCS_ARTIFACTS_KEY" >> "${ARTIFACTS_FOLDER}/logs/gcloud_auth.log" 2>&1
    - |
        for i in {1..3}; do
          if gsutil -q stat "gs://xsoar-ci-artifacts/$GCS_LOCKS_PATH/machines_locks/*-${LOCK_MACHINE_NAME}-lock-${CI_PIPELINE_ID}" 2>/dev/null; then
            echo "File found in GCS bucket."
            export CLOUD_CHOSEN_MACHINE_IDS=${LOCK_MACHINE_NAME}
            echo 'export CLOUD_CHOSEN_MACHINE_IDS=${LOCK_MACHINE_NAME}' > CloudEnvVariables
            echo "CLOUD Chosen machine ids are:${CLOUD_CHOSEN_MACHINE_IDS}" | tee "${ARTIFACTS_FOLDER}/logs/lock_file.txt"
            break
          else
            echo "File not found. Retrying in 120 seconds..."
            sleep 120
          fi
        done
        if [[ "${i}" -gt 3 ]]; then
          echo "Couldn't find lock file after 3 attempts  with machine id: ${LOCK_MACHINE_NAME} and this pipeline id: ${CI_PIPELINE_ID}"
          job-done
          exit "${EXIT_CODE}"
        fi
    - else
    -   !reference [.lock-machine]
    - fi
    - !reference [.uninstall-packs-and-reset-bucket-cloud]
    - !reference [.cloud-machine-information]
    - job-done
    - exit "${EXIT_CODE}"
  after_script:
    - source .gitlab/helper_functions.sh
    - !reference [ .unlock-machine ]
  timeout: 4 hours
  variables:
    CLOUD_MACHINES_TYPE: $CLOUD_MACHINES_TYPE
    CLOUD_MACHINES_COUNT: $CLOUD_MACHINES_COUNT
    GCS_LOCKS_PATH: $GCS_LOCKS_PATH
    INSTANCE_ROLE: "XSIAM"
    PRODUCT_TYPE: "XSIAM"
    SERVER_TYPE: "XSIAM"
    GCS_QUEUE_FILE: "queue-ga"
    CLOUD_SERVERS_FILE: "xsiam_servers_path"
    CLOUD_API_KEYS: $XSIAM_API_KEYS
    CLOUD_API_TOKENS: $XSIAM_TOKENS
    ARTIFACTS_FOLDER_MPV2: "${CI_PROJECT_DIR}/artifacts/marketplacev2"
    ARTIFACTS_FOLDER: "${ARTIFACTS_FOLDER_MPV2}"
    ARTIFACTS_FOLDER_INSTANCE: "${ARTIFACTS_FOLDER_MPV2}/instance_${INSTANCE_ROLE}"
    ARTIFACTS_FOLDER_SERVER_TYPE: "${ARTIFACTS_FOLDER_MPV2}/server_type_${SERVER_TYPE}"
    ENV_RESULTS_PATH: "${ARTIFACTS_FOLDER_SERVER_TYPE}/env_results.json"
    GCS_MARKET_BUCKET: "${GCS_MARKET_V2_BUCKET}"
    GCS_SOURCE_BUCKET: "marketplace-v2-dist"
    GCS_MACHINES_BUCKET: "marketplace-v2-dist-dev/upload-flow/builds-xsiam"
    MARKETPLACE_NAME: "marketplacev2"
    NON_REMOVABLE_PACKS: "Base"
    RESET_CORE_PACK_VERSION: "false"

fan-in-build-machines-cleanup:
  tags:
    - gke
  stage: fan-in
  extends:
    - .build-machines-cleanup-rule-always
  script:
    - echo "fan in"

slack-notify-build-machines-cleanup:
  extends:
    - .trigger-slack-notification
    - .build-machines-cleanup-rule-always
  variables:  # Passes the environment variable from the parent pipeline to the child which can be useful for cases when triggering pipeline with alternate env variable value passed in the API call.
    PIPELINE_ID: $CI_PIPELINE_ID
    WORKFLOW: 'Build Machines Cleanup'
    JOB_NAME: 'fan-in-build-machines-cleanup'
    SLACK_CHANNEL: $SLACK_CHANNEL
    SLACK_JOB: 'true'
    SLACK_ALLOW_FAILURE: 'false'
    CI_PROJECT_ID: $CI_PROJECT_ID
    CI_SERVER_URL: $CI_SERVER_URL
    JIRA_SERVER_URL: $JIRA_SERVER_URL
    JIRA_VERIFY_SSL: $JIRA_VERIFY_SSL
    JIRA_API_KEY: $JIRA_API_KEY
    JIRA_PROJECT_ID: $JIRA_PROJECT_ID
    JIRA_ISSUE_UNRESOLVED_TRANSITION_NAME: $JIRA_ISSUE_UNRESOLVED_TRANSITION_NAME
