
.build-machines-cleanup-rule:
  tags:
    - $BUILD_JOB_TAG
  rules:
    - if: '$BUILD_MACHINES_CLEANUP == "true"'

.build-machines-cleanup-rule-always:
  rules:
    - if: '$BUILD_MACHINES_CLEANUP == "true"'
      when: always

.create_artifacts_and_server_type_instance_folders: &create_artifacts_and_server_type_instance_folders
  - section_start "Create Artifacts, Server Instance, Server Type folders" --collapsed
  - |
    if [[ -n "${ARTIFACTS_FOLDER}" ]] && [[ ! -d "${ARTIFACTS_FOLDER}/logs" ]]; then
      echo "Creating Artifacts folder: ${ARTIFACTS_FOLDER} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER}/logs" # using the -p to create the logs folder as well.
    fi
  - |
    if [[ -n "${ARTIFACTS_FOLDER_INSTANCE}" ]] && [[ ! -d "${ARTIFACTS_FOLDER_INSTANCE}/logs" ]]; then
      echo "Creating Artifacts instance folder: ${ARTIFACTS_FOLDER_INSTANCE} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER_INSTANCE}/logs" # using the -p to create the logs folder as well.
      echo "${INSTANCE_ROLE}" > "${ARTIFACTS_FOLDER_INSTANCE}/instance_role.txt"
    fi
  - |
    if [[ -n "${ARTIFACTS_FOLDER_SERVER_TYPE}" ]] && [[ ! -d "${ARTIFACTS_FOLDER_SERVER_TYPE}/logs" ]]; then
      echo "Creating Artifacts Server type folder: ${ARTIFACTS_FOLDER_SERVER_TYPE} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER_SERVER_TYPE}/logs" # using the -p to create the logs folder as well.
      echo "${SERVER_TYPE}" > "${ARTIFACTS_FOLDER_SERVER_TYPE}/server_type.txt"
    fi
  - section_end "Create Artifacts, Server Instance, Server Type folders"

.before-script-build-machines-cleanup:
  before_script:
    - source .gitlab/helper_functions.sh
    - !reference [.setup-network-certs]
    - !reference [.poetry-install]
    - !reference [.granting_execute_permissions_on_files]
    - !reference [.setup-artifactory]
    - *create_artifacts_and_server_type_instance_folders
    - !reference [.create-artifacts-repositories-folder]
    - !reference [.clone-content-test-conf]

.lock-machine:
  - section_start "Lock Machine" --collapsed
  - ./Tests/scripts/lock_cloud_machines.sh
  - |
    if [ ! -s "${ARTIFACTS_FOLDER}/locked_machines_list.txt" ]; then
      echo "No machines were locked, exiting..."
      job-done
      exit 0
    fi
  - export CLOUD_CHOSEN_MACHINE_IDS=$(cat "${ARTIFACTS_FOLDER}/locked_machines_list.txt")
  - echo "CLOUD Chosen machine ids are:${CLOUD_CHOSEN_MACHINE_IDS}"
  - section_end "Lock Machine"

.uninstall-packs-and-reset-bucket-cloud:
  - section_start "Uninstall Packs and Reset Bucket Cloud" --collapsed
  - ./Tests/scripts/uninstall_packs_and_reset_bucket_cloud.sh || EXIT_CODE=$?
  - section_end "Uninstall Packs and Reset Bucket Cloud"

.cloud-machine-information:
  - section_start "Cloud Machine information"
  - ./Tests/scripts/print_cloud_machine_details.sh
  - section_end "Cloud Machine information"

.unlock-machine:
  - section_start "Unlock Machine" --collapsed
  - |
    if [[ -f "${ARTIFACTS_FOLDER}/locked_machines_list.txt" ]]; then
      export CLOUD_CHOSEN_MACHINE_IDS=$(cat "${ARTIFACTS_FOLDER}/locked_machines_list.txt")

      if [[ -n "${CLOUD_CHOSEN_MACHINE_IDS}" ]]; then
        if [[ -e "${ARTIFACTS_FOLDER}/locked_machines_list.txt" ]]; then
          echo "Job finished, removing lock file for machine ids:${CLOUD_CHOSEN_MACHINE_IDS}"
          gsutil rm "gs://xsoar-ci-artifacts/$GCS_LOCKS_PATH/machines_locks/*-lock-$CI_PIPELINE_ID*"
          echo "Finished removing lock file(s)"
        else
          echo "No lock file found, skipping unlocking"
        fi
      else
        echo "No machine ids were chosen, skipping unlocking"
      fi
    else
      echo "No locked_machines_list.txt file found, skipping unlocking"
    fi
  - section_end "Unlock Machine"

build-machines-cleanup:
  stage: cleanup
  extends:
    - .build-machines-cleanup-rule
    - .before-script-build-machines-cleanup
  script:
    - EXIT_CODE=0
    - |
      if [[ -n "$OLD_PIPELINE" ]]; then
        echo "triggered by pipeline: ${OLD_PIPELINE}"
      fi
      echo "lock machine name ${LOCK_MACHINE_NAME}"
    - if [[ -n "$LOCK_MACHINE_NAME" ]]; then
    -   echo "Check if lock file already exist "
    - |
        export FILE_FOUND=false
        for i in {1..3}; do
          if gsutil -q stat "gs://xsoar-ci-artifacts/$GCS_LOCKS_PATH/machines_locks/*-${LOCK_MACHINE_NAME}-lock-${CI_PIPELINE_ID}" 2>/dev/null; then
            echo "File found in GCS bucket."
            export CLOUD_CHOSEN_MACHINE_IDS=${LOCK_MACHINE_NAME}
            echo "${LOCK_MACHINE_NAME}" > "${ARTIFACTS_FOLDER}/locked_machines_list.txt"
            echo "CLOUD Chosen machine ids are:${CLOUD_CHOSEN_MACHINE_IDS}"
            export FILE_FOUND=true
            break
          else
            echo "File not found. Retrying in 120 seconds..."
            sleep 120
          fi
        done
        if [[ "${FILE_FOUND}" == "false" ]]; then
          echo "Couldn't find lock file after 3 attempts  with machine id: ${LOCK_MACHINE_NAME} and this pipeline id: ${CI_PIPELINE_ID}"
          job-done
          exit "${EXIT_CODE}"
        fi
    - else
    -   !reference [.lock-machine]
    - fi
    - !reference [.uninstall-packs-and-reset-bucket-cloud]
    - !reference [.cloud-machine-information]
    - job-done
    - exit "${EXIT_CODE}"
  tags:
    - $BUILD_JOB_TAG
  after_script:
    - source .gitlab/helper_functions.sh
    - !reference [ .unlock-machine ]
  timeout: 5 hours
  variables:
    CLOUD_MACHINES_TYPE: $CLOUD_MACHINES_TYPE
    CLOUD_MACHINES_COUNT_MINIMUM_CONDITION: $CLOUD_MACHINES_COUNT_MINIMUM_CONDITION
    CLOUD_MACHINES_COUNT_TIMEOUT_CONDITION: $CLOUD_MACHINES_COUNT_TIMEOUT_CONDITION
    CLOUD_MACHINES_TIMEOUT: $CLOUD_MACHINES_TIMEOUT
    GCS_LOCKS_PATH: $GCS_LOCKS_PATH
    INSTANCE_ROLE: "XSIAM"
    PRODUCT_TYPE: "XSIAM"
    SERVER_TYPE: "XSIAM"
    GCS_QUEUE_FILE: "queue-ga"
    ARTIFACTS_FOLDER_MPV2: "${CI_PROJECT_DIR}/artifacts/marketplacev2"
    ARTIFACTS_FOLDER: "${ARTIFACTS_FOLDER_MPV2}"
    ARTIFACTS_FOLDER_INSTANCE: "${ARTIFACTS_FOLDER_MPV2}/instance_${INSTANCE_ROLE}"
    ARTIFACTS_FOLDER_SERVER_TYPE: "${ARTIFACTS_FOLDER_MPV2}/server_type_${SERVER_TYPE}"
    ENV_RESULTS_PATH: "${ARTIFACTS_FOLDER_SERVER_TYPE}/env_results.json"
    GCS_MARKET_BUCKET: "${GCS_MARKET_V2_BUCKET}"
    GCS_SOURCE_BUCKET: "marketplace-v2-dist"
    GCS_MACHINES_BUCKET: "marketplace-v2-dist-dev/upload-flow/builds-xsiam"
    MARKETPLACE_NAME: "marketplacev2"
    NON_REMOVABLE_PACKS: "Base"
    RESET_CORE_PACK_VERSION: "false"
    OLD_PIPELINE: ""

fan-in-build-machines-cleanup:
  tags:
    - gke
  stage: fan-in
  extends:
    - .build-machines-cleanup-rule-always
  script:
    - echo "fan in"

slack-notify-build-machines-cleanup:
  extends:
    - .build-machines-cleanup-rule-always
    - .trigger-slack-notification
  variables:  # Passes the environment variable from the parent pipeline to the child which can be useful for cases when triggering pipeline with alternate env variable value passed in the API call.
    PIPELINE_TO_QUERY: $CI_PIPELINE_ID
    JOB_NAME: 'fan-in-build-machines-cleanup'
    WORKFLOW: 'Build Machines Cleanup'
    SLACK_CHANNEL: $SLACK_CHANNEL
    SLACK_JOB: 'true'
    SLACK_ALLOW_FAILURE: 'false'
    CI_PROJECT_ID: $CI_PROJECT_ID
    CI_SERVER_URL: $CI_SERVER_URL
