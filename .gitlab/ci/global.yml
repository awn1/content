.trigger-slack-notification:
  stage: .post
  inherit: # see https://gitlab.com/gitlab-org/gitlab-runner/-/issues/27775
    variables: false
  trigger:
    strategy: depend
    include:
      - local: .gitlab/ci/slack-notify.yml

.setup-network-certs:
  - chmod 700 $NETWORK_SETUP
  - source $NETWORK_SETUP

.default-before-script:
  before_script:
    - source .gitlab/helper_functions.sh
    - !reference [.setup-network-certs]

.default-job-settings:
  interruptible: true
  extends:
    - .default-before-script

.poetry-install:
  - section_start "poetry-install" --collapsed
  # Install Poetry
  - python3 .hooks/install.python-poetry.py --version "${POETRY_VERSION}"
  # - curl -sSL https://install.python-poetry.org | python3 - --version "${POETRY_VERSION}"
  - poetry install
  - section_end "poetry-install"

.setup-artifactory:
  - section_start "Setup Artifactory" --collapsed
  - chmod 700 ${ARTIFACTORY_SETUP_SCRIPT}
  - source ${ARTIFACTORY_SETUP_SCRIPT}
  - section_end "Setup Artifactory"

.create_artifacts_folder:
  - section_start "Create Artifacts" --collapsed
  - |
    if [[ -n "${ARTIFACTS_FOLDER}" ]] && [[ ! -d "${ARTIFACTS_FOLDER}/logs" ]]; then
      echo "Creating Artifacts folder: ${ARTIFACTS_FOLDER} and it's log folder"
      mkdir -p -m 777 "${ARTIFACTS_FOLDER}/logs" # using the -p to create the logs folder as well.
    fi
  - section_end "Create Artifacts"

.create-artifacts-repositories-folder:
  - section_start "Create Artifacts Repositories Folder" --collapsed
  - |
    if [[ ! -d "${CI_PROJECT_DIR}/artifacts/repositories" ]]; then
      echo "Creating repositories folder:${CI_PROJECT_DIR}/artifacts/repositories"
      mkdir -p -m 777 "${CI_PROJECT_DIR}/artifacts/repositories" # using the -p to create the folder hierarchy.
    fi
  - section_end "Create Artifacts Repositories Folder"

.granting_execute_permissions_on_files:
  - section_start "Granting execute permissions on files" --collapsed
  - chmod +x ./Tests/scripts/*
  - chmod +x ./Tests/Marketplace/*
  - chmod +x ./SecretActions/SecretsBuild/*
  - section_end "Granting execute permissions on files"

.check-is-force-merged-allowed:
  - section_start "Check is force merged allowed"
  - |
    echo "Checking if the MR is a force merge, user login:${GITLAB_USER_LOGIN}, user name:${GITLAB_USER_NAME}, labels:${CI_MERGE_REQUEST_LABELS}"
    if echo "${CI_MERGE_REQUEST_LABELS}" | grep -q "Force Merge"; then
      if [[ -z "${ALLOWED_USERS_FORCE}" ]]; then
        echo "ALLOWED_USERS_FORCE is not set, exiting"
        exit 1
      fi
      if echo "${ALLOWED_USERS_FORCE}" | grep -q "${GITLAB_USER_LOGIN}"; then
        echo "The MR is a force merge by ${GITLAB_USER_LOGIN}"
        job-done
        exit 0
      else
        echo "The MR is a force merge, but the user ${GITLAB_USER_LOGIN} is not allowed to force merge"
        exit 1
      fi
    else
      echo "The MR is not a force merge"
    fi
  - section_end "Check is force merged allowed"

.clone-content-test-conf:
  - section_start "Clone content test conf" --collapsed
  - exec 3>&1 4>&2
  - exec > >(tee -a "${ARTIFACTS_FOLDER}/logs/clone_demisto_content_test_conf.log") 2>&1
  - |
    set +e

    RED='\033[0;31m'
    GREEN='\033[0;32m'
    BLUE='\033[0;34m'
    YELLOW='\033[1;33m'
    PURPLE='\033[0;36m'
    NC='\033[0m'

    clone_repository() {
      local host=$1
      local user=$2
      local token=$3
      local repo_name=$4
      local branch=$5
      local retry_count=$6
      local sleep_time=${7:-10}  # default sleep time is 10 seconds.
      local exit_code=0
      local i=1
      echo -e "${PURPLE}Checking if repository repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} already exists in ${CI_PROJECT_DIR}/artifacts/repositories/${repo_name}${NC}"
      if [ -d "${CI_PROJECT_DIR}/artifacts/repositories/${repo_name}" ]; then
        echo -e "${GREEN}Repository ${repo_name} already exists, no need to clone it again${NC}"
        return 0
      fi
      echo -e "${PURPLE}Cloning repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} from ${host} branch:${branch} with ${retry_count} retries${NC}"
      if [ -z "${user}" ] && [ -z "${token}" ]; then
        user_info=""
      else
        user_info="${user}:${token}@"
        # If either user or token is not empty, then we need to add them to the url.
      fi
      pushd "${CI_PROJECT_DIR}/artifacts/repositories" || exit 1
      for ((i=1; i <= retry_count; i++)); do
        git -c advice.detachedHead=false clone --depth=1 "https://${user_info}${host}/${CI_PROJECT_NAMESPACE}/${repo_name}.git" --branch "${branch}" && exit_code=0 && break || exit_code=$?
        if [ ${i} -ne "${retry_count}" ]; then
          echo -e "${YELLOW}Failed to clone repository:${repo_name}, with branch:${branch}, project namespace:${CI_PROJECT_NAMESPACE}, exit code:${exit_code}, sleeping for ${sleep_time} seconds and trying again${NC}"
          sleep "${sleep_time}"
        else
          echo -e "${RED}Failed to clone repository:${repo_name} with branch:${branch}, project namespace:${CI_PROJECT_NAMESPACE}, exit code:${exit_code}, exhausted all ${retry_count} retries${NC}"
          break
        fi
      done
      popd || exit 1
      return ${exit_code}
    }

    clone_repository_with_fallback_branch() {
      local host=$1
      local user=$2
      local token=$3
      local repo_name=$4
      local branch=$5
      local retry_count=$6
      local sleep_time=${7:-10}  # default sleep time is 10 seconds.
      local fallback_branch="${8:-master}"

      # Check if branch exists in the repository.
      echo -e "${PURPLE}Checking if branch/tag ${branch} exists in repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE}${NC}"
      if [ -z "${user}" ] && [ -z "${token}" ]; then
        user_info=""
      else
        # If either user or token is not empty, then we need to add them to the url.
        user_info="${user}:${token}@"
      fi
      local tag_exists
      local branch_type="branch"
      if [[ ${branch} =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "branch ${branch} is formatted like a version (v0.0.0), checking for a matching tag"
          git ls-remote --exit-code --quiet --tags "https://${user_info}${host}/${CI_PROJECT_NAMESPACE}/${repo_name}.git" "${branch}" 1>/dev/null 2>&1
          tag_exists=$?
          if [[ "${tag_exists}" -ne 0 ]]; then
            echo -e "${PURPLE}Could not find a tag called ${branch}${NC}"
          else
            branch_type="tag"
            echo -e "${GREEN}Found a tag called ${branch}${NC}"
          fi
      else
          echo "branch ${branch} is not formatted like a version (v0.0.0), skipping tag check"
          tag_exists=-1 # default, for when the branch isn't version-like named
      fi

      if [[ "${tag_exists}" -ne 0 ]]; then
          echo "Searching for a branch called ${branch}"
          git ls-remote --exit-code --quiet --heads "https://${user_info}${host}/${CI_PROJECT_NAMESPACE}/${repo_name}.git" "${branch}" 1>/dev/null 2>&1
          local branch_exists=$?
      fi

      if [[ "${tag_exists}" -ne 0 ]] && [[ "${branch_exists}" -ne 0 ]]; then
        echo -e "${YELLOW}branch/tag:${branch} does not exist in repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE}, defaulting to ${fallback_branch}${NC}"
        local exit_code=1
      else
        echo -e "${GREEN}${branch_type}:${branch} exists in repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE}, trying to clone${NC}"
        clone_repository "${host}" "${user}" "${token}" "${repo_name}" "${branch}" "${retry_count}" "${sleep_time}"
        local exit_code=$?
        if [ "${exit_code}" -ne 0 ]; then
          echo -e "${YELLOW}Failed to clone repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} with ${branch_type}:${branch}, exit code:${exit_code}${NC}"
        fi
      fi
      if [ "${exit_code}" -ne 0 ]; then
        # Trying to clone from fallback branch.
        echo -e "${PURPLE}Trying to clone repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} with fallback branch ${fallback_branch}!${NC}"
        clone_repository "${host}" "${user}" "${token}" "${repo_name}" "${fallback_branch}" "${retry_count}" "${sleep_time}"
        local exit_code=$?
        if [ ${exit_code} -ne 0 ]; then
          echo -e "${RED}ERROR: Failed to clone repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} with fallback branch:${fallback_branch}, exit code:${exit_code}, exiting!${NC}"
          exit ${exit_code}
        else
          echo -e "${GREEN}Successfully cloned repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} with fallback branch:${fallback_branch}${NC}"
          return 0
        fi
      else
        echo -e "${GREEN}Successfully cloned repository:${repo_name}, project namespace:${CI_PROJECT_NAMESPACE} with branch:${branch}${NC}"
        return 0
      fi
    }
    clone_repository_with_fallback_branch "${CI_SERVER_HOST}" "gitlab-ci-token" "${CI_JOB_TOKEN}" "content-test-conf" "${CI_COMMIT_REF_NAME}" 3 10 "master"

    if [ ! -d "${CI_PROJECT_DIR}/config" ]; then mkdir -p "${CI_PROJECT_DIR}/config"; else echo "Directory ${CI_PROJECT_DIR}/config already exists"; fi
    cp -r "${CI_PROJECT_DIR}/artifacts/repositories/content-test-conf/config/"* "${CI_PROJECT_DIR}/config/"

    NAME_MAPPING_PATH="${CI_PROJECT_DIR}/config/name_mapping.json"
    if [ ! -f "${NAME_MAPPING_PATH}" ]; then
      echo "File ${NAME_MAPPING_PATH} does not exist, exiting!"
      exit 1;
    fi
    set -e
    export CLOUD_SAAS_SERVERS_PATH="${CI_PROJECT_DIR}/config/saas_servers.json"
    if [ ! -f "${CLOUD_SAAS_SERVERS_PATH}" ]; then
      echo "File ${CLOUD_SAAS_SERVERS_PATH} does not exist, exiting!"
      exit 1
    fi
    export SAAS_SERVERS_VERSIONS_PATH="${CI_PROJECT_DIR}/config/servers_tenants_versions.json"
    if [ ! -f "${SAAS_SERVERS_VERSIONS_PATH}" ]; then
      echo "File ${SAAS_SERVERS_VERSIONS_PATH} does not exist, exiting!"
      exit 1
    fi
    echo "Successfully cloned content-test-conf repository"

  - exec 1>&3 2>&4
  - exec 3>&- 4>&-
  - section_end "Clone content test conf"

.docker_services:
  services:
    - name: ${DOCKER_IO}/library/docker:20.10.12-dind
      alias: docker
      variables:
        KUBERNETES_MEMORY_REQUEST: ${KUBERNETES_MEMORY_REQUEST}
        KUBERNETES_MEMORY_LIMIT: ${KUBERNETES_MEMORY_LIMIT}
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""