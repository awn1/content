from typing import Tuple
from CommonServerPython import *

''' STANDALONE FUNCTION '''


def create_commands(device_ids: List[str], file_path: str, file_hash: str):
    """
    Create a list of `Command` of the remove file command to `Cortex XDR` and `CrowdstrikeFalcon`

    :param device_ids: device IDs to run on
    :param file_path: path of the file to delete
    :param file_hash: hash of the file to delete
    :return: A list of `Command` for the script
    """
    cs_os_to_ids = get_crowdstrike_os_to_id(device_ids)
    incident_id = demisto.incident()['id']

    falcon_command = CommandRunner.Command(
        commands='cs-falcon-rtr-remove-file',
        args_lst=[{
            'host_ids': ','.join(ids),
            'file_path': file_path, 'os': os_,
        } for os_, ids in cs_os_to_ids.items()]
    )

    microsoft_atp_command = CommandRunner.Command(
        commands='microsoft-atp-stop-and-quarantine-file',
        args_lst={
            'machine_id': ','.join(device_ids),
            'file_hash': file_hash,
            'comment': f'Action was taken by Cortex XSOAR - incident #{incident_id}',
        }
    )

    path_based_commands = {falcon_command}
    hash_based_commands = {microsoft_atp_command}

    commands = set()
    if file_path:
        commands.update(path_based_commands)
    if file_hash:
        commands.update(hash_based_commands)

    return list(commands)


def get_crowdstrike_os_to_id(device_ids: List[str]) -> Dict[str, Set[str]]:
    """
    Get the OS for each device id

    :param device_ids: List of device ids
    :return: A mapping between the OS (Windows, Linux, Mac) and the devices
    """
    endpoint_executor = CommandRunner.Command(brand='CrowdstrikeFalcon',
                                              commands='endpoint',
                                              args_lst={'id': ','.join(device_ids)})
    endpoint_results, _ = CommandRunner.execute_commands(endpoint_executor,
                                                         extract_contents=True)
    os_to_ids: Dict[str, Set[str]] = {}
    for endpoint_res in endpoint_results:
        if not isinstance(endpoint_res.result, dict):
            continue
        for endpoints in endpoint_res.result.get('resources', []):
            if not isinstance(endpoints, list):
                endpoints = [endpoints]
            for endpoint in endpoints:
                os_ = endpoint.get('platform_name')
                if os_ not in os_to_ids:
                    os_to_ids[os_] = set()
                os_to_ids[os_].add(endpoint.get('device_id'))
    return os_to_ids


def run_remove_file(device_ids: List[str], file_path: str, file_hash: str) -> list:
    """
    Given arguments to the command, returns a list of results to return
    :param device_ids: List of device ids to remove the file from
    :param file_path: Path of the file to remove
    :param file_hash: Hash of the file to remove (only supported on MSDE)
    :return: list of results to return
    :rtype: ``list``
    """
    # creating a command object for each supported integration
    help = file_path + '1'
    xdr_command = CommandRunner.Command(
        commands='xdr-file-delete-script-execute',
        args_lst={
            'endpoint_ids': ','.join(device_ids),
            'file_path': help,
        }
    )
    command_executors = create_commands(device_ids, file_path, file_hash)
    res, err = CommandRunner.execute_commands(xdr_command, extract_contents=False)
    res=res[0] if res else res
    err = err[0] if err else err
    headers = ['Instance', 'Command', 'Result', 'Comment']
    if res:
        res.args.pop('using', None)
        res.args.pop('using-brand', None)
        command = {'command': res.command,
                    'args': res.args}
        comment = res.result.get('Contents', 'No contents found, see entry.') if isinstance(res.result, dict) else None
        xdr_results = {'Instance': '***{brand}***: {instance}'.format(brand=res.brand,
                                                                                        instance=res.instance),
                                        'Command': command,
                                        'Result': 'Success',
                                        'Comment': comment}
    elif err:
        # don't care about using arg in command
        err.args.pop('using', None)
        err.args.pop('using-brand', None)
        command = {'command': err.command,
                    'args': err.args}
        xdr_results = {'Instance': '***{brand}***: {instance}'.format(brand=err.brand,
                                                                                        instance=err.instance),
                                        'Command': command,
                                        'Result': 'Error',
                                        'Comment': err.result}
    xdr_summary_md = tableToMarkdown('Polling Summary results', xdr_results, headers=headers, is_auto_json_transform=True)
    return_value = CommandRunner.run_commands_with_summary(command_executors)
    return_value.append(CommandResults(readable_output=xdr_summary_md))
    if isinstance(res.result, dict) and res.result.get('HumanReadable'):
        res.result['HumanReadable'] = "***{brand} ({instance})***\n{human_readable}".format(
            brand=res.brand,
            instance=res.instance,
            human_readable=res.result.get('HumanReadable'))
    command_results = res.result
    return_value.append(command_results)
    if not command_results:
        if err:  # no results were given but there are errors
            errors = ["{instance}: {msg}".format(instance=err.instance, msg=err.result)]
            error_msg = '\n'.join(['Script failed. The following errors were encountered: '] + errors)
        else:
            error_msg = 'The commands that run are not supported in this Instance. ' \
                        'Try to configure the integrations in XSOAR settings.'
        raise DemistoException(error_msg)
    return return_value


''' MAIN FUNCTION '''


def main():  # pragma: no cover
    try:
        args = demisto.args()
        if not argToBoolean(args.get('approve_action', False)):
            raise ValueError('approve_action must be `yes`')
        device_ids = argToList(args.get('device_ids'))
        file_path = args.get('file_path', '')
        file_hash = args.get('file_hash', '')
        if not device_ids:
            raise ValueError('Device id is not specified')
        if not (file_path or file_hash):
            raise ValueError('Neither path nor hash(es) of the file(s) to delete were specified.')
        return_results(run_remove_file(device_ids, file_path, file_hash))
    except Exception as e:
        return_error(f'Failed to execute RemoveFileWrapper. Error: {str(e)}')


''' ENTRY POINT '''

if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
